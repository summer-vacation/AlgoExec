划分方法  
排序算法划分方法有：稳定性，内外排序，时空复杂度  

按照稳定性划分，稳定排序，如果a原本在b前面，而a=b，排序之后a仍然在b的前面；而不稳定可能出现在b之后。  

按照内外排序划分，内排序，所有排序操作都在内存中完成；外排序 ：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；  

按照时空复杂度划分，时间复杂度是指运行时间，空间复杂度运行完一个程序所需内存的大小。  

总结：  
  ![总结](019.png) 
  
图片名词解释：  
n: 数据规模  
k: “桶”的个数  
In-place: 占用常数内存，不占用额外内存  
Out-place: 占用额外内存  

#### 选择排序（Selection Sort）  
![选择排序](001.gif)  

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。  
时间复杂度：O(n^2)  


#### 冒泡排序（Bubble Sort）  
![冒泡排序](002.gif)     

![冒泡排序](003.gif)    
对相邻元素之间的比较，可以将大的数慢慢“沉底”(数组尾部)  
稳定排序，内排序，时间复杂度：O(n^2)  


#### 插入排序（Insertion Sort）
![插入排序](04.gif)     

![插入排序](005.gif)  
前面已排序数组找到插入的位置  
稳定排序，内排序，时间复杂度：O(n^2)  

#### 希尔排序（Shell Sort）  
![希尔排序](006.gif)  

![希尔排序](007.png)  

选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。  
先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：  
步骤1：选择一个增量序列t_1，t_2，…，t_kt，其中t_i>t_j，t_k=1  
步骤2：按增量序列个数k，对序列进行k 趟排序；  
步骤3：每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度  

非稳定排序，内排序；  
希尔排序的时间复杂度和增量序列是相关的。  
{1,2,4,8,...}这种序列并不是很好的增量序列，使用这个增量序列的时间复杂度（最坏情形）是O(n^2)  
Hibbard提出了另一个增量序列{1,3,7，...,2^k-1}，这种序列的时间复杂度(最坏情形)为O(n^{1.5})  
Sedgewick提出了几种增量序列，其最坏情形运行时间为O(n^{1.3})，其中最好的一个序列是{1,5,19,41,109,...}；


#### 归并排序（Merge Sort）  
归并排序，采用是分治法，先将数组分成子序列，让子序列有序，再将子序列间有序，合并成有序数组。

算法描述：
1. 把长度为n的输入序列分成长度 n/2的子序列；
2. 对两个子序列采用归并排序；
3. 合并所有子序列。

![归并排序](009.gif)  

![归并排序](010.gif)  
稳定排序，外排序（占用额外内存），时间复杂度O(nlogn)

#### 快速排序（Quick Sort）
快速排序是选取一个“哨兵”(pivot)，将小于pivot放在左边，把大于pivot放在右边，分割成两部分，并且可以固定pivot在数组的位置，在对左右两部分继续进行排序。

快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：

步骤1：从数列中挑出一个元素，称为 “基准”（pivot ）；
步骤2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
步骤3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

![快速排序](011.gif)  

![快速排序](012.gif)  
不稳定排序，内排序，时间复杂度度O(nlogn)

#### 堆排序（Heap Sort）  
堆排序是利用堆这个数据结构设计的排序算法。  

算法描述：  
建堆，从底向上调整堆，使得父亲节点比孩子节点值大，构成大顶堆；  
交换堆顶和最后一个元素，重新调整堆。  

![堆排序](013.gif)  

![堆排序](014.gif) 

不稳定排序，内排序，时间复杂度为O(nlogn)  

#### 计数排序（Counting Sort）

计数排序是典型的空间换时间算法，开辟额外数据空间存储用索引号记录数组的值和数组值个数  
算法描述：
1. 找出待排序的数组的最大值和最小值  
2. 统计数组值的个数  
3. 反向填充目标数组  

![计数排序](015.gif)  

稳定排序，外排序，时间复杂度O(n + k)O(n+k)，但是对于数据范围很大的数组，需要大量时间和内存

#### 桶排序（Bucket Sort）
桶排序是计数排序的升级版，原理是：输入数据服从均匀分布的，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的算法或是以递归方式继续使用桶排序，此文编码采用递归方式）  
算法描述：
1. 人为设置一个桶的BucketSize，作为每个桶放置多少个不同数值（意思就是BucketSize = 5，可以放5个不同数字比如[1, 2, 3,4,5]也可以放 100000个3，只是表示该桶能存几个不同的数值）
2. 遍历待排序数据，并且把数据一个一个放到对应的桶里去
3. 对每个不是桶进行排序，可以使用其他排序方法，也递归排序
4. 不是空的桶里数据拼接起来  

![桶排序](016.png)  
稳定排序，外排序，时间复杂度O(n + k)O(n+k)，k为桶的个数


#### 基数排序（Radix Sort）
基数排序是对数字每一位进行排序，从最低位开始排序  
算法描述：  
1. 找到数组最大值，得最大位数；
2. 从最低位开始取每个位组成radix数组；
3. 对radix进行计数排序（计数排序适用于小范围的特点）  

![基数排序](017.gif)   
稳定排序，外排序，时间复杂度 posCount * (n + n)，其中 posCount 为数组中最大元素的最高位数；简化下得：$O( k *n ) $；其中k为常数，n为元素个数














